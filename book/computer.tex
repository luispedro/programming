\chapter{What is a Computer?}

To the post office, it might be a four pound parcel; to the hardware engineer,
a diagram of components, engineered to work together; for a programmer, it is
mostly a composition of three parts: (1) memory, (2) the processor, and (3)
magic.

Get a sheet of paper and draw three squares:

\[
[ ] [ ] [ ]
\]

Now, write 3 in the first square, 4 in the second:

\[
[ 3 ] [ 4 ] [  ]
\]

Now perform the following steps:

\begin{enumerate}
\item Write a zero in the third square.
\item Add the number in the second square and the number in the last square
together. Remember it for a second.
\item Erase (or cross-out) the number in the third square and replace it with
the result of your addition.
\item Subtract on from the first square (again, replacing the previous result
by one-minus).
\item If the first square is zero, we are done. Otherwise, go to 2.
\end{enumerate}

\emph{Voil√†}, this is your first program. Here is what happens when you run through it:

\begin{align*}
[ 3 ] [ 4 ] [ 0 ] & (step 1)\\
[ 3 ] [ 4 ] [ 0 ] & (step 2, 4+0=4)\\
[ 3 ] [ 4 ] [ \not0 4 ] & (step 3)\\
[ \not3 2 ] [ 4 ] [ \not0 4 ] & (step 4)\\
[ \not3 2 ] [ 4 ] [ \not0 4 ] & (step 5, go to nr.\ 2)\\
[ \not3 2 ] [ 4 ] [ \not0 4 ] & (step 2, 4+4=8)\\
[ \not3 2 ] [ 4 ] [ \not0 \not4 8 ] & (step 3)\\
[ \not3 \not2 1 ] [ 4 ] [ \not0 \not4 8 ] & (step 4)\\
[ \not3 \not2 1 ] [ 4 ] [ \not0 \not4 8 ] & (step 5, go to nr.\ 3)\\
[ \not3 \not2 1 ] [ 4 ] [ \not0 \not4 8 ] & (step 2, 4+8=12)\\
[ \not3 \not2 1 ] [ 4 ] [ \not0 \not4 \not8 12 ] & (step 3)\\
[ \not3 \not2 \not1 0 ] [ 4 ] [ \not0 \not4 \not8 12 ] & (step 4)\\
[ \not3 \not2 \not1 0 ] [ 4 ] [ \not0 \not4 \not8 12 ] & (step 5, and we are done)
\end{align*}

What we are doing here, as you may have figured out, is multiplying the two
numbers in the first cells, by repeated addition. We transformed a basic
operation (addition), into a slightly more complex operation (multiplication).
This is what programming is: taking some basic operations, that the computer
processor can execute and building them up to more complex
operations.\footnote{Nowadays, most processors already have instructions that
perform multiplication, but at one point, they did use repeated addition.}

Here is how the previous program could look like in a more ``real'' programming
language:

\begin{verbatim}
mov M[2], 0\\
performaddition:\\
add M[1], M[2]\\
dec M[0] \\
jnz performaddition
\end{verbatim}

Let's decode this a bit more carefully. The first thing you may have noticed is
that I have called the first cell 0, the second cell 1, and the third cell 2.
This may seem strange, but there are good reasons for this (FIXME: Add link to
the Dekstra paper where he makes that argument).

The first instruction \instruction{mov} moves a value into a cell. In this
case, moves the value 0 into the cell \instruction{M[2]}. Then we have a label
for the next instruction (which will be useful later). The \instruction{add}
instruction performs in-place addition (i.e., replaces the content of its first
argument with the result of adding it to its second argument\footnote{How could
you handle the case where you do not want to lose any of the arguments, but
still get the result of the addition? }

\begin{exercise}
How would you perform addition on a machine that has only a \instruction{inc}
and a \instruction{dec} instruction (which increments and decrements its
argument) and the conditional jump instructions \instruction{jz} and
\instruction{jnz}? No \instruction{mov} or \instruction{add} exist in this
hypothetical machine. Your arguments are in cells~0 and~1, and your result
should be in cell~2. It is acceptable to change the values in~$M[0]$ and
$M[1]$.
\begin{solution}
\begin{verbatim}
inc M[0]
dec M[1]
jz mov1pre
mov0:
inc M[2]
mov1pre:
inc M[1]
dec M[1]
jz done
mov1:
dec M[0]
jnz mov0
mov1:
inc M[1]
dec M[0]
jnz mov1
done:
\end{verbatim}

Note the trick we use at the beginning to check whether an argument is zero:
increment and decrement it.
\end{solution}
\end{exercise}

\begin{exercise}
How would you change the program you wrote to make sure that, at the end of it,
the input cells have their original values? (\emph{Hint}: you can use extra
cells as scratch space).
\begin{solution}
The way to approach this is the following: first copy cell 0 into cell 3, and
cell 1 into 4. Then, you can use the previous program to add 3 and~4 into 2.

So, how do you copy a cell? You copy $M[0]$ into two cells ($M[3]$ and $M[4]$)
and then you copy $M[4]$ back. Notice that we temporarily erase the value in
$M[0]$ and then write it back!

\begin{verbatim}
copy0first:
inc M[3]
inc M[4]
dec M[0]
jnz copy0first
copy0second:
inc M[0]
dec M[4]
jnz copy0second
\end{verbatim}
\end{solution}
\end{exercise}

\section{Magic}

So far, in this chapter, we have referred to many aspects of computers as
\textit{magic}, namely everything that had to deal with input/output (often
abbreviated as \textsc{io}). We now look at how this magic is achieved.

All of the magic is achieved through specialty hardware functionality. For
example, the processor might have a special pair of \instruction{in} and
\instruction{out} instructions, which are used to read and write to devices.
This was used in earlier Intel processors, but recent models tend to use
\emph{memory-mapped \textsc{io}}.

In memory mapped \textsc{io}, the \textsc{cpu} behaves as if it was writing to
a memory address, but instead of actually writing to memory, it sends commands
to the device. Simple devices such as mice or keyboards will have simple
electronics, but others, such as printers, will often have a power processor
and some internal memory of its own. In any case, the device will know how to
handle the incoming commands.

