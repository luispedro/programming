\chapter{What is a Computer?}

To the post office, it might be a four pound parcel; to the hardware engineer,
a diagram of components, engineered to work together; for a programmer, it is
mostly a composition of three parts: (1) memory, (2) the processor, and (3)
magic.

\section{Assembly Code}

Get a sheet of paper and draw three squares:

\newcommand\dorect[1]{\framebox[6em]{\ensuremath{#1}\strut\hfill}}%
\newcommand\dostate[3]{\dorect{#1}\hspace{2pt}\dorect{#2}\hspace{2pt}\dorect{#3}}

\[
\dostate{}{}{}
\]

Now, write 3 in the first square, 4 in the second:


\[
\dostate{3}{4}{\strut}
\]

Now perform the following steps:

\begin{enumerate}
\item Write a zero in the third square.
\item Add the number in the second square and the number in the last square
together. Remember it for a second.
\item Erase (or cross-out) the number in the third square and replace it with
the result of your addition.
\item Subtract on from the first square (again, replacing the previous result
by one-minus).
\item If the first square is zero, we are done. Otherwise, go to 2.
\end{enumerate}

\emph{Voil√†}, this is your first program. Here is what happens when you run through it:

\begin{tabular}{ll}
\dostate{3}{4}{0} & (step 1)\\
\dostate{3}{4}{0} & (step 2, 4+0=4)\\
\dostate{3}{4}{\not0 4} & (step 3)\\
\dostate{\not3 \, 2 }{4}{\not0 \, 4} & (step 4)\\
\dostate{\not3 \, 2 }{4}{\not0 \, 4} & (step 5, go to nr.\ 2)\\
\dostate{\not3 \, 2 }{4}{\not0 \, 4} & (step 2, 4+4=8)\\
\dostate{\not3 \, 2 }{4}{\not0 \not4 \, 8} & (step 3)\\
\dostate{\not3 \not2 \, 1}{4}{\not0 \not4 \, 8} & (step 4)\\
\dostate{\not3 \not2 \, 1}{4}{\not0 \not4 \, 8} & (step 5, go to nr.\ 3)\\
\dostate{\not3 \not2 \, 1}{4}{\not0 \not4 \, 8} & (step 2, 4+8=12)\\
\dostate{\not3 \not2 \, 1}{4}{\not0 \not4 \not8 \, 12} & (step 3)\\
\dostate{\not3 \not2 \not1 \, 0}{4}{\not0 \not4 \not8 \, 12} & (step 4)\\
\dostate{\not3 \not2 \not1 \, 0}{4}{\not0 \not4 \not8 \, 12} & (step 5, and we are done)
\end{tabular}

What we are doing here, as you may have figured out, is multiplying the two
numbers in the first cells, by repeated addition. We transformed a basic
operation (addition), into a slightly more complex operation (multiplication).
This is what programming is: taking some basic operations, that the computer
processor can execute and building them up to more complex
operations.\footnote{Nowadays, most processors already have instructions that
perform multiplication, but at one point, they did use repeated addition.}

Here is how the previous program could look like in a more ``real'' programming
language:

\begin{verbatim}
mov M[2], 0
performaddition:
add M[1], M[2]
dec M[0]
jnz performaddition
\end{verbatim}

Let's decode this a bit more carefully. The first thing you may have noticed is
that I have called the first cell 0, the second cell 1, and the third cell 2.
This may seem strange, but there are good reasons for this.\footnote{
E. Dijkstra, a computing pioneer, wrote a long article about this, available at
http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html}.

The first instruction \instruction{mov} moves a value into a cell. In this
case, moves the value 0 into the cell \instruction{M[2]}. Then we have a label
for the next instruction (which will be useful later). The \instruction{add}
instruction performs in-place addition (i.e., replaces the content of its first
argument with the result of adding it to its second argument.\footnote{How could
you handle the case where you do not want to lose any of the arguments, but
still get the result of the addition?} The \instruction{dec} instruction
decrements its argument (i.e., subtracts one from it). Finally,
\instruction{jnz} stands for \emph{jump if not zero}. If the result of the
previous operation (in this case, \instruction{dec}) is \emph{not zero}, then
it jumps to the instruction given by the label \instruction{performaddition}.

\begin{exercise}
How would you perform addition on a machine that has only a \instruction{inc}
and a \instruction{dec} instruction (which increments and decrements its
argument) and the conditional jump instructions \instruction{jz} and
\instruction{jnz}? No \instruction{mov} or \instruction{add} exist in this
hypothetical machine. Your arguments are in cells~0 and~1, and your result
should be in cell~2. It is acceptable to change the values in~$M[0]$ and
$M[1]$.
\begin{solution}
\begin{verbatim}
inc M[0]
dec M[1]
jz mov1pre
mov0:
inc M[2]
mov1pre:
inc M[1]
dec M[1]
jz done
mov1:
dec M[0]
jnz mov0
mov1:
inc M[1]
dec M[0]
jnz mov1
done:
\end{verbatim}

Note the trick we use at the beginning to check whether an argument is zero:
increment and decrement it.
\end{solution}
\end{exercise}

\begin{exercise}
How would you change the program you wrote to make sure that, at the end of it,
the input cells have their original values? (\emph{Hint}: you can use extra
cells as scratch space).
\begin{solution}
The way to approach this is the following: first copy cell 0 into cell 3, and
cell 1 into 4. Then, you can use the previous program to add 3 and~4 into 2.

So, how do you copy a cell? You copy $M[0]$ into two cells ($M[3]$ and $M[4]$)
and then you copy $M[4]$ back. Notice that we temporarily erase the value in
$M[0]$ and then write it back!

\begin{verbatim}
copy0first:
inc M[3]
inc M[4]
dec M[0]
jnz copy0first
copy0second:
inc M[0]
dec M[4]
jnz copy0second
\end{verbatim}
\end{solution}
\end{exercise}

\section{Memory \& The Processor}

First, we review binary notation of numbers. Normally, we write a number as a
sequence of decimal digits. For example, $245$ is interpreted to mean: $2
\times 100 + 4 \times 10 + 5 \times 1$. Starting from the left, each position
has a value that is 10~times larger than the previous position. Binary numbers,
such as $1101_2$ (we will use the little $_2$-subscript or a $_{10}$ subscript
to emphacise which basis we are using) as the same. The first position (from
the left) has value~1, the second position value~2, then~4, then~8\ldots

\[
1101_2 = 1 \times 2^{0}  + 0 \times 2 + 2^1 \times 4 + 2^2 \times 2^3 = 13_{10}
\]

Sometimes, too much is made of binary notation. In this book, all that matters
is that you understand that numbers can be expressed as binary.\footnote{Read
the mathemical foreword (page~\pageref{chpt:mathforeword}), if you do not
understand the $2^3$ notation.}

We can now start formalising things a bit more. What we called ``cells'' above
are what is normally called memory. The first thing to realise it that the
cells can only store a limited set of numbers. Physically, each cell is
composed of little wires where you either have electric current or you do not.
If you do, we say that this part of the cell is~1, otherwise, we call
it~0.\footnote{This convention is purely arbitrary and other technologies
exist, some of which have called existence of current~0 and its absence~1.}
Looking at the state of each wire, we get a \emph{bit} of information (the
simplest building block, something that has only two possible states). By
convention, each cell has 8~little wires, and can store numbers such as
$01011101_2$ (which is $93_{10}$). If you work it out, the maximum number that
can be stored ($11111111_2$) is 255.

We call an 8-bit number, a \emph{byte}. There is nothing magical about it being
8~bits. In the past, machines existed with 6~bit bytes. But eight became
popular, and is now a widely used convention. Throughout the book, you will see
this pattern again and again: things are a certain way because it is convenient
that we all agree on a common definition, but the definition is more or less
arbitrary.

Each cell can save a single byte (a number between 0 and 255). When we say a
computer has a 1~Gigabyte memory, we mean that it has about a trillion of these
cells. It is also important to note that the cells are ordered. They are not
just a jumbled pile, but more like graph paper. The first cell is numbered~0,
the second cell~1, all the way to 1073741823 (if you have that many in your
computer).
%\footnote{If the number 1073741823 seems odd, read the note on kilos
%and megas.}

\subsection{About kilos and megas}

How many bytes does a kilobyte have? This question used to have a simple,
clear, answer:~1024. It might have been a slight abuse of language to use the
prefix ``kilo'', which normally means 1000 (in the metric system, a kilogram is
1000 grams, a kilometer 1000 metres\ldots), but 1024 was the more meaningful
unit. 1024 is $2^{10}$, so it's a nice round number ($1000000000_2$), while
1000 is not ($1111101000_2$).

More recently, some felt that this was an unacceptable abuse and that the
metric standard should be followed more closely and this resulted in complete
confusion. While a kilobyte still mostly refers to 1024, sometimes it is now
used to mean 1000 bytes. This is also why a 500~GB drive is identified as
having less than 500~GB. The manufacturer is just using the definition that is
most convenient for them.

To try to make sense of this mess, the new words kibibyte (and mebibyte, and
gibibyte) were coined to mean $2^{10}$, $2^{20}$ and $2^{30}$. I have actually
never heard anyone saying them out loud, but many programs use them
(mostly their abbreviated forms KiB, MiB, and GiB). Everyone still says
megabyte to mean $2^{20}$ Bytes. In fact, if the difference would matter, we
always mean the old convention as decimal notation is foreign to the computer
world. So, after all of this, we might get a new equilibrium between the old
convention where everybody knew that kilobyte was 1024, the intermediate
confusion where some people insisted on the non-standard standard of ``kilo is
1000'' and nobody was ever sure what was meant, and a new compromise where we
write ``MiB'' and read it as ``megabyte.''

\section{Processor}

The processor is a device which reads in the program and execute its
instructions. There are two types of instructions: those that change the
contents of memory cells and those that control what parts of the program to
execute next.

In the above, we imagined a processor with some very simple arithmetic
instructions and some very simple conditional jump instructions. Actually,
those are exactly the sort of instruction that a real processor has.

\section{Representations}

One obvious question is the following: where does this program live, how does
it actually exist? A related question is: how can the computer represent
anything other than numbers? We know that computers can save texts, pictures,
sounds, and much more. In fact, it is not even clear how we could represent
numbers greater than 255.

To represent numbers greater than 255, we can simply use several cells
together. If we use 2~cells, 2~Bytes, we can get numbers with 16~bits; Using
4~cells, we can get numbers with 32~bits (up to 4 million, roughly); and with
8~cells, we can get 64~bits. We could, of course, use a 5 Byte number, but,
typically, we do not do that.

So, what about non-numbers?  The answer is very simple: we represent these
things using numbers. For example, for text, we can make up a mapping such that
A is 0, B is 1\ldots and use that to represent a text.

Pictures and sounds are also represented as a collection of numbers. A picture
(a digital picture) is a rectangle of pixels (picture elements), which are
small, single-colour blocks. We can represent each pixel with 3 numbers, one
for the amount or red, one for green, and one for blue. Each pixel takes up 3
Bytes. If an image has 2048 pixels across and is 1344 pixels tall, then we need
7.85 MiB to store it. The first Byte will be the red component of the top-left
corner, then its blue component,\ldots

We explore this aspect much more in later chapters.

What about programs? They are simply numbers too. There is a fixed set of
instructions, so we might have a table assigning numbers to each of them, plus
a way to encode their arguments.

One question that you might have is the following: if you have a piece of
memory with its values, how do you know whether you should interpret it as text
or as sound or as a program? You do not. Memory only hold values,
interpretation must be elsewhere. In fact, this is one source of many problems,
as we will see.

\section{Programming Languages}

The basic programs we saw above were written in assembly language. Assembly is
just one step above the actual numbers that the computer uses, it is simply a
textual representation of them.

It is not a very flexible programming language and any program you write will
only be adapted to that specific computer architecture.

Therefore, most of the time, programs are written in what are called
\emph{higher-level} languages, where most of the boring work is automatically
done by a program. For example, here is a program in a higher level language

\begin{verbatim}
a = 2
b = 3
print a+4*b
\end{verbatim}

We can write this as a file (a collection of Bytes, i.e., numbers such that it
encodes the above text). There is then a program, called an interpreter, which
takes this program and is going to decode it and perform instructions such that
some memory cell will contain the value 2 (which is called \code{a}), another
the value 3 (which is called \code{b}) and then an arithmetic operation is
performed and through \emph{magic}, the result (14) is printed on the screen.

The interpreter takes care of details such as assigning memory locations to
human-readable names and many other details that would be very bothersome to
keep track of and that a computer can do for you.

\section{Magic}

So far, in this chapter, we have referred to many aspects of computers as
\textit{magic}, namely everything that had to deal with input/output (often
abbreviated as \textsc{io}). We now look at how this magic is achieved.

All of the magic is achieved through specialty hardware functionality. For
example, the processor might have a special pair of \instruction{in} and
\instruction{out} instructions, which are used to read and write to devices.
This was used in earlier Intel processors, but recent models tend to use
\emph{memory-mapped \textsc{io}}.

In memory mapped \textsc{io}, the \textsc{cpu} behaves as if it was writing to
a memory address, but instead of actually writing to memory, it sends commands
to the device. Simple devices such as mice or keyboards will have simple
electronics, but others, such as printers, will often have a power processor
and some internal memory of its own. In any case, the device will know how to
handle the incoming commands.

